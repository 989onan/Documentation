= Save Game

Save Games curtial for keeping state information of machines etc. between game sessions.
The save games contain infromation about stuff like what items are in your inventory.
Normaly Satisfactory saves the current game state periodicly in 5 minutes.
But you can still trigger a save manually.

You can find your save files in `%localappdata%/FactoryGame/Saved/SaveGames/`

But what actually happens when you push this magical "save" button?

== How is the game state saved?

Saving the game state is in a nutshell prety easy.
You just simply itterate over all objects in the world
and convert them to data you can write to a file, like a string.

Unreal converts its objects to a string wich is json formatted.

This process of converting a `UObject` to this json string is called serialization.

The problem, it makes absolutely no sense to load every god damn object there is in the world.
Because some of them get automatically spawned on the game boot up
or they dont contain infromation that actually needs to get saved.
F.e. we don't store every tree in the game to the save file, but what we actually do is,
when the player removes a tree by cutting it down, we store the information that the tree is not there anymore.
Basically, exactly the oppsite, we store that there is no information.
We also don't care about the terrain because the user can't change it, and so, it is allways the same
so we don't need to serialize it.
A constructor on the other hand, is not placed directly on boot up of the game, so we need to store it,
when it is place in the world.

Also, Actors like machines consist of multiple components
were some of them hold information we might want to store, like UFGInventoryComponent.
But we don't care about a StaticMesh f.e. because it always gets created in runtime.

== The SaveGame UProperty Flag

Not all attributes of a object get serialized,
only UProperties marked with the `SaveGame`-Flag get actually serialized.

In BP you can add this flag by opening the advanced property settings and check `SaveGame`.

[WARNING]
====
Make sure you have not set the `SkipSerialization` onto the property or the object.
This would end in the save system wanting to save but the unreal serializer just ignoring your data.

But in default, it shouldn't be set.
====

== The IFGSaveInterface

The save system of Satisfactory uses the IFGSaveInterface to filter now between objects we need to save,
and objects we don't need to save.

On of the most important functions is the `bool ShouldSave() const` function,
wich returns true when the object should get saved.
This can be dependent on the sate of the object, like the trees.
The trees only return true if they are actually removed.

This means,
when you have information you want to keep between game sessions, you should implement `IFGSaveInterface`
and return on `ShouldSave` true.

[Warning]
====
`FGBuildable` implements `IFGSaveInterface` already, but it doesn't return true in `ShouldSave`,
so please make sure you overwrite the function and return true.
====

All the other function allow you to further customize the serialization and filter progress
when the save state gets stored or loaded.

== Loading a Save Game

When a save game gets loaded, it goes through multiple steps until the player is allowed to play on the map again.
In the first step the UMap gets loaded and unserialized to the UWorld
(this unserialization happens because the map is also just a serialized world,
that means this doesnt load the save game, just the by CSS predifined map)

After that the save game gets loaded.
The seccond step now spawns all additional actors into the world.
So their constructors get executed and those create now subobjects like actor components, attributes, etc.

The third step is to load the saved variable values.
It sets the values of the newley spawned actors but also of the subobject of them and even the already
existent actors in the world.

Now as the forth and last step all the begin play functions get called and the components and actors start to tick.

With that, the save game got loaded.

In this whole process some functions of the IFGSaveInterface might got called to additonally inform the actors of the different load states and for custom serialization.
